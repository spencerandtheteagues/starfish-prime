import Fastify from 'fastify'; import cors from '@fastify/cors'; import websocket from '@fastify/websocket'; import { PromptSchema } from './schema.js'; import { startRun, pushRun } from './runs.js'; import { bus } from './events.js'; import { stat } from 'node:fs/promises'; import { join } from 'node:path'; import archiver from 'archiver'; import { pushMsg, cancelRun } from './runmgr.js';
const PORT=Number(process.env.PORT||4001); const ORIGINS=(process.env.ALLOWED_ORIGINS||'').split(',').map(s=>s.trim()).filter(Boolean); const RUNS_DIR=process.env.RUNS_DIR||'runs';
const app=Fastify({logger:true}); await app.register(cors,{origin:(origin,cb)=>{ if(ORIGINS.length===0) return cb(null,true); if(!origin||ORIGINS.includes(origin)) return cb(null,true); cb(new Error('Origin not allowed'),false); }}); await app.register(websocket);
app.get('/health', async()=>({ ok:true, ts: new Date().toISOString() }));
app.post('/runs', async (req, reply)=>{ const body:any=req.body||{}; const parsed=PromptSchema.safeParse(body); if(!parsed.success) return reply.code(400).send({error:'invalid'}); const { runId } = await startRun(RUNS_DIR, parsed.data, !!body.scaffold, !!body.useSpecKit); return { runId }; });
app.post('/runs/:id/message', async (req, reply)=>{ const id=(req.params as any).id; const msg=(req.body as any)?.message; if(!msg) return reply.code(400).send({error:'missing message'}); pushMsg(id, String(msg)); bus.emit('evt',{ ts:Date.now(), runId:id, kind:'log', step:'architect', message:`User: ${msg}`}); return { ok:true }; });
app.post('/runs/:id/cancel', async (req, reply)=>{ cancelRun((req.params as any).id); return { ok:true }; });
app.post('/runs/:id/push', async (req, reply)=>{ try{ const out=await pushRun(RUNS_DIR, (req.params as any).id); return out; }catch(e:any){ return reply.code(400).send({ error: e?.message||String(e) }); } });
app.get('/ws',{websocket:true},(conn,req)=>{ const runId=(req.query as any)?.runId; const handler=(evt:any)=>{ if(!runId||evt.runId===runId) conn.socket.send(JSON.stringify(evt)); }; bus.on('evt',handler); conn.socket.on('close',()=>bus.off('evt',handler)); });
app.get('/runs/:id/artifacts.zip', async (req, reply)=>{ const id=(req.params as any).id; const folder=join(RUNS_DIR,id); try{ await stat(folder);}catch{ return reply.code(404).send({error:'Run not found'});} reply.header('Content-Type','application/zip'); reply.header('Content-Disposition',`attachment; filename="${id}-artifacts.zip"`); const archive=archiver('zip',{zlib:{level:9}}); archive.on('error',(err)=>{ reply.raw.destroy(err); }); archive.pipe(reply.raw); archive.directory(folder,false); await archive.finalize(); });
app.get('/runs/:id/app.zip', async (req, reply)=>{ const id=(req.params as any).id; const folder=join(RUNS_DIR,id,'app'); try{ await stat(folder);}catch{ return reply.code(404).send({error:'App not generated for this run'});} reply.header('Content-Type','application/zip'); reply.header('Content-Disposition',`attachment; filename="${id}-app.zip"`); const archive=archiver('zip',{zlib:{level:9}}); archive.on('error',(err)=>{ reply.raw.destroy(err); }); archive.pipe(reply.raw); archive.directory(folder,false); await archive.finalize(); });
app.listen({port:PORT,host:'0.0.0.0'}).catch((err)=>{ app.log.error(err); process.exit(1); });
