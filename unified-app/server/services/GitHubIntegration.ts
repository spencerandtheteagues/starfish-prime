import { Octokit } from '@octokit/rest';
import { EventEmitter } from 'events';

interface CreateRepoRequest {
  name: string;
  description: string;
  code: Record<string, string>;
  isPrivate?: boolean;
}

interface GitHubRepo {
  id: number;
  name: string;
  full_name: string;
  description: string;
  url: string;
  clone_url: string;
  ssh_url: string;
  default_branch: string;
}

export class GitHubIntegration extends EventEmitter {
  private octokit: Octokit | null = null;
  private ready = false;
  private authenticated = false;

  constructor() {
    super();
    this.initialize();
  }

  private async initialize() {
    // Initialize Octokit if GitHub token is available
    if (process.env.GITHUB_TOKEN) {
      this.octokit = new Octokit({
        auth: process.env.GITHUB_TOKEN,
      });

      // Test authentication
      try {
        await this.octokit.rest.users.getAuthenticated();
        this.authenticated = true;
        console.log('‚úÖ GitHub authentication successful');
      } catch (error) {
        console.warn('‚ö†Ô∏è GitHub authentication failed:', error);
        this.authenticated = false;
      }
    } else {
      console.warn('‚ö†Ô∏è GITHUB_TOKEN not provided, GitHub integration disabled');
    }

    this.ready = true;
    this.emit('ready');
  }

  isReady(): boolean {
    return this.ready;
  }

  isAuthenticated(): boolean {
    return this.authenticated;
  }

  async createRepository(request: CreateRepoRequest): Promise<GitHubRepo> {
    if (!this.octokit || !this.authenticated) {
      // Return mock repo if GitHub is not available
      return this.createMockRepo(request);
    }

    try {
      console.log('üî® Creating GitHub repository:', request.name);

      // Create the repository
      const { data: repo } = await this.octokit.rest.repos.createForAuthenticatedUser({
        name: this.sanitizeRepoName(request.name),
        description: request.description,
        private: request.isPrivate || false,
        auto_init: true,
        gitignore_template: 'Node',
        license_template: 'mit'
      });

      console.log('‚úÖ Repository created:', repo.full_name);

      // Upload files to the repository
      await this.uploadFilesToRepo(repo.owner.login, repo.name, request.code);

      return {
        id: repo.id,
        name: repo.name,
        full_name: repo.full_name,
        description: repo.description || '',
        url: repo.html_url,
        clone_url: repo.clone_url,
        ssh_url: repo.ssh_url,
        default_branch: repo.default_branch
      };
    } catch (error) {
      console.error('‚ùå Failed to create GitHub repository:', error);
      throw new Error(`GitHub repository creation failed: ${error}`);
    }
  }

  async uploadFilesToRepo(owner: string, repo: string, files: Record<string, string>) {
    if (!this.octokit) return;

    console.log(`üìÅ Uploading ${Object.keys(files).length} files to ${owner}/${repo}`);

    // Get the current commit SHA to create files against
    const { data: branch } = await this.octokit.rest.repos.getBranch({
      owner,
      repo,
      branch: 'main'
    });

    const currentCommitSha = branch.commit.sha;

    // Prepare all files for batch upload
    const tree = [];
    for (const [path, content] of Object.entries(files)) {
      tree.push({
        path: this.sanitizePath(path),
        mode: '100644' as const,
        type: 'blob' as const,
        content: content
      });
    }

    // Create a new tree
    const { data: newTree } = await this.octokit.rest.git.createTree({
      owner,
      repo,
      tree,
      base_tree: currentCommitSha
    });

    // Create a new commit
    const { data: newCommit } = await this.octokit.rest.git.createCommit({
      owner,
      repo,
      message: 'üöÄ Initial commit from Starfish Prime\n\nGenerated by AI-powered application builder',
      tree: newTree.sha,
      parents: [currentCommitSha]
    });

    // Update the main branch to point to the new commit
    await this.octokit.rest.git.updateRef({
      owner,
      repo,
      ref: 'heads/main',
      sha: newCommit.sha
    });

    console.log('‚úÖ Files uploaded successfully');
  }

  async createRenderDeployButton(owner: string, repo: string): Promise<string> {
    const deployUrl = `https://render.com/deploy?repo=https://github.com/${owner}/${repo}`;

    // Create a deploy button markdown
    const deployButton = `
## üöÄ Deploy to Render

[![Deploy to Render](https://render.com/images/deploy-to-render-button.svg)](${deployUrl})

Click the button above to deploy this application to Render automatically.
    `.trim();

    // Update README with deploy button
    if (this.octokit && this.authenticated) {
      try {
        const { data: readmeFile } = await this.octokit.rest.repos.getContent({
          owner,
          repo,
          path: 'README.md'
        });

        if ('content' in readmeFile) {
          const currentReadme = Buffer.from(readmeFile.content, 'base64').toString();
          const updatedReadme = currentReadme + '\n\n' + deployButton;

          await this.octokit.rest.repos.createOrUpdateFileContents({
            owner,
            repo,
            path: 'README.md',
            message: 'üìù Add Render deploy button',
            content: Buffer.from(updatedReadme).toString('base64'),
            sha: readmeFile.sha
          });
        }
      } catch (error) {
        console.warn('Failed to update README with deploy button:', error);
      }
    }

    return deployUrl;
  }

  async forkRepository(owner: string, repo: string): Promise<GitHubRepo> {
    if (!this.octokit || !this.authenticated) {
      throw new Error('GitHub authentication required');
    }

    const { data: fork } = await this.octokit.rest.repos.createFork({
      owner,
      repo
    });

    return {
      id: fork.id,
      name: fork.name,
      full_name: fork.full_name,
      description: fork.description || '',
      url: fork.html_url,
      clone_url: fork.clone_url,
      ssh_url: fork.ssh_url,
      default_branch: fork.default_branch
    };
  }

  async getRepositoryContent(owner: string, repo: string, path?: string): Promise<any> {
    if (!this.octokit) {
      throw new Error('GitHub integration not available');
    }

    const { data } = await this.octokit.rest.repos.getContent({
      owner,
      repo,
      path: path || ''
    });

    return data;
  }

  async searchRepositories(query: string, language?: string): Promise<any[]> {
    if (!this.octokit) {
      return [];
    }

    const searchQuery = language ? `${query} language:${language}` : query;

    const { data } = await this.octokit.rest.search.repos({
      q: searchQuery,
      sort: 'stars',
      order: 'desc',
      per_page: 20
    });

    return data.items;
  }

  private createMockRepo(request: CreateRepoRequest): GitHubRepo {
    const repoName = this.sanitizeRepoName(request.name);
    const mockOwner = 'demo-user';

    return {
      id: Date.now(),
      name: repoName,
      full_name: `${mockOwner}/${repoName}`,
      description: request.description,
      url: `https://github.com/${mockOwner}/${repoName}`,
      clone_url: `https://github.com/${mockOwner}/${repoName}.git`,
      ssh_url: `git@github.com:${mockOwner}/${repoName}.git`,
      default_branch: 'main'
    };
  }

  private sanitizeRepoName(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9-]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '')
      .substring(0, 100) || 'generated-app';
  }

  private sanitizePath(path: string): string {
    return path.replace(/\\/g, '/').replace(/^\/+/, '');
  }
}